一、Set
特点：
（1）新的数据结构 Set，类似于数组，但是成员的值都是唯一的，没有重复的值。
数组去重 
[...new Set([1,2,2,'2',5,5])]

function dedupe(array) {
  return Array.from(new Set(array));
}
dedupe([1, 1, 2, 3])

（2）Set 本身是一个构造函数，用来生成 Set 数据结构，具有iterable 接口。Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
const s = new Set();
[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));
for (let i of s) {
  console.log(i);
}

const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

const set = new Set(document.querySelectorAll('div'));
set.size 

const set = new Set();
document
 .querySelectorAll('div')
 .forEach(div => set.add(div));
set.size 

（3）Set 加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值，特殊的地方NaN
let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}

(4)Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用


1、实例属性
Set.prototype.constructor：构造函数，默认就是Set函数。
Set.prototype.size：返回Set实例的成员总数。
new Set([1,2,2,'2',5,5]).size

2、实例的方法( 操作方法 | 遍历方法 )
add(value)：添加某个值，返回 Set 结构本身。
let s = new Set();
s.add(1).add(2).add(2);

delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
let s = new Set([1,2,3]);
s.delete(2);

has(value)：返回一个布尔值，表示该值是否为Set的成员。
let s = new Set([1,2,3]);
s.has(4);

clear()：清除所有成员，没有返回值。
let s = new Set([1,2,3]);
s.clear();
console.dir(s);

keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员

由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值）
let set = new Set(['red', 'green', 'blue']);
for (let item of set.keys()) {
  console.log(item);
}
for (let item of set.values()) {
  console.log(item);
}
for (let item of set[Symbol.iterator]()) {
  console.log(item);
}
for (let item of set.entries()) {
  console.log(item);
}

Set.prototype[Symbol.iterator] === Set.prototype.values
for (let x of set) {
  console.log(x);
}

let set = new Set();
set.add(function(){console.log(1)});
set.add(function(){console.log(3)});
set.add(function(){console.log(2)});
set.forEach((value, key) => value());

3、遍历方法的应用
数组的map和filter方法也可以间接用于 Set
let set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x * 2));
// 返回Set结构：{2, 4, 6}
let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x => (x % 2) == 0));
// 返回Set结构：{2, 4}

可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}
// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}
// 差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
console.dir(union);
console.dir(intersect);
console.dir(difference);

同步改变原来的 Set 结构
// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val => val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val => val * 2));
// set的值是2, 4, 6



WeakSet

(1) 成员只能是对象，而不能是其他类型的值
const ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set

(2)WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。WeakSet 适合临时存放一组对象
WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。

WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。
const foos = new WeakSet()
class Foo {
  constructor() {
    foos.add(this)
  }
  method () {
    if (!foos.has(this)) {
      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
    }
  }
}
这里使用 WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。


(3)WeakSet 是一个构造函数,可以接受一个数组或类似数组的对象(任何具有 Iterable 接口的对象,对象成员也是对象)作为参数
const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);

const b = [3, 4];//参数对象成员也是对象
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)

(4)方法
WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员
WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员
WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
const ws = new WeakSet();
const obj = {};
const foo = {};

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo);    // false

ws.delete(window);
ws.has(window);    // false


二、Map
